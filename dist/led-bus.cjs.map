{"version":3,"file":"led-bus.cjs","sources":["../src/ASCIIHex14Seg.js","../src/index.js","../src/utils.js"],"sourcesContent":["/*\n *  Project     Segmented LED Display - ASCII Library\n *  @author     David Madison (adapted to JS by Deviant Syndrome)\n *  @link       github.com/dmadison/Segmented-LED-Display-ASCII\n *  @license    MIT - Copyright (c) 2017 David Madison, 2021 Deviant Syndrome\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n */\n\n/** @type {number[]} */\nexport const fourteenSegmentASCII = [\n    0x0000, /* (space) */\n    0x4006, /* ! */\n    0x0202, /* \" */\n    0x12CE, /* # */\n    0x12ED, /* $ */\n    0x3FE4, /* % */\n    0x2359, /* & */\n    0x0200, /* ' */\n    0x2400, /* ( */\n    0x0900, /* ) */\n    0x3FC0, /* * */\n    0x12C0, /* + */\n    0x0800, /* , */\n    0x00C0, /* - */\n    0x4000, /* . */\n    0x0C00, /* / */\n    0x0C3F, /* 0 */\n    0x0406, /* 1 */\n    0x00DB, /* 2 */\n    0x008F, /* 3 */\n    0x00E6, /* 4 */\n    0x2069, /* 5 */\n    0x00FD, /* 6 */\n    0x0007, /* 7 */\n    0x00FF, /* 8 */\n    0x00EF, /* 9 */\n    0x1200, /* : */\n    0x0A00, /* ; */\n    0x2440, /* < */\n    0x00C8, /* = */\n    0x0980, /* > */\n    0x5083, /* ? */\n    0x02BB, /* @ */\n    0x00F7, /* A */\n    0x128F, /* B */\n    0x0039, /* C */\n    0x120F, /* D */\n    0x0079, /* E */\n    0x0071, /* F */\n    0x00BD, /* G */\n    0x00F6, /* H */\n    0x1209, /* I */\n    0x001E, /* J */\n    0x2470, /* K */\n    0x0038, /* L */\n    0x0536, /* M */\n    0x2136, /* N */\n    0x003F, /* O */\n    0x00F3, /* P */\n    0x203F, /* Q */\n    0x20F3, /* R */\n    0x00ED, /* S */\n    0x1201, /* T */\n    0x003E, /* U */\n    0x0C30, /* V */\n    0x2836, /* W */\n    0x2D00, /* X */\n    0x00EE, /* Y */\n    0x0C09, /* Z */\n    0x0039, /* [ */\n    0x2100, /* \\ */\n    0x000F, /* ] */\n    0x2800, /* ^ */\n    0x0008, /* _ */\n    0x0100, /* ` */\n    0x1058, /* a */\n    0x2078, /* b */\n    0x00D8, /* c */\n    0x088E, /* d */\n    0x0858, /* e */\n    0x14C0, /* f */\n    0x048E, /* g */\n    0x1070, /* h */\n    0x1000, /* i */\n    0x0A10, /* j */\n    0x3600, /* k */\n    0x0030, /* l */\n    0x10D4, /* m */\n    0x1050, /* n */\n    0x00DC, /* o */\n    0x0170, /* p */\n    0x0486, /* q */\n    0x0050, /* r */\n    0x2088, /* s */\n    0x0078, /* t */\n    0x001C, /* u */\n    0x0810, /* v */\n    0x2814, /* w */\n    0x2D00, /* x */\n    0x028E, /* y */\n    0x0848, /* z */\n    0x0949, /* { */\n    0x1200, /* | */\n    0x2489, /* } */\n    0x0CC0, /* ~ */\n    0x0000, /* (del) */\n]\n\n/** @type {string[]} */\nexport const segments = [\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g1\",\n    \"g2\",\n    \"h\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"dp\"\n]","import { fourteenSegmentASCII, segments } from \"./ASCIIHex14Seg\"\nimport { hex2bin, offsetTextWrap } from \"./utils\";\n\nconst ASCII_OFFSET = 32\nconst NUM_SEGS = 14\nconst NUM_SEG_W_DP = NUM_SEGS + 1\nconst CODE_DP = \"dp\"\n\nexport class LEDEncoder {\n    /** @type {number} */\n    numDisplays\n    /** @type {LEDEncoder~SegmentCommandHandler} */\n    segmentCommandHandler\n    /** @type {number} */\n    offset = 0\n    /** @type {LEDEncoder~EncoderOptions} */\n    options\n    /** @type {LEDEncoder~EncoderOptions} */\n    defaultOptions = {\n        decimalPointSupport: true\n    }\n\n    /** @type {LEDEncoder~SegmentCommandHandler} */\n    dpSupportCheckingHandler = (dNum, seg, on) => {\n        if (seg === CODE_DP && !this.options.decimalPointSupport) {\n            return\n        }\n        this.segmentCommandHandler(dNum, seg, on)\n    }\n\n    /**\n     * Creates a LEDEncoder instance\n     *\n     * @param {number} numDisplays\n     * @param {LEDEncoder~SegmentCommandHandler} segmentCommandHandler\n     * @param {LEDEncoder~EncoderOptions} [options]\n     */\n    constructor(numDisplays, segmentCommandHandler, options) {\n        this.numDisplays = numDisplays\n        this.segmentCommandHandler = segmentCommandHandler\n        this.options = {\n            ...this.defaultOptions,\n            ...options\n        }\n    }\n\n    /**\n     * Encodes text fragment into sequence of segment LED commands\n     * Text fragment size is determined by the number of LED displays\n     * passed to the class\n     *\n     * @param {string} text - Text to encode\n     */\n    sendText(text) {\n        for (let chNum = 0; chNum < text.substr(0, this.numDisplays).length; chNum++) {\n            let count = 0\n            let binaryString = hex2bin(fourteenSegmentASCII[text.charCodeAt(chNum) - ASCII_OFFSET], NUM_SEG_W_DP)\n            Array.from(binaryString).forEach(b => {\n                this.dpSupportCheckingHandler(chNum, segments[NUM_SEGS - count], b === '1')\n                count++\n            })\n        }\n    }\n\n    /**\n     * Encodes text fragment into sequence of segment LED commands, refreshed every\n     *\n     * @param {string} textString - Text to encode\n     * @param {number} [scrollSpeed] - Scrolling speed in milliseconds, defaults to 1000\n     */\n    sendScrollingText(textString, scrollSpeed) {\n        let timeout = scrollSpeed || 1000;\n        setTimeout(() => {\n            this.sendText(offsetTextWrap(this.offset, this.offset + this.numDisplays, textString));\n            this.offset++\n            if (this.offset === textString.length) {\n                this.offset = 0\n            }\n            this.sendScrollingText(textString, timeout)\n        }, timeout)\n    }\n\n    /**\n     * Handler for LED segment commands, inside this callback you can put\n     * any type of LED display visualisation you prefer, like drawing an SVG,\n     * canvas, or plain HTML\n     *\n     * @callback LEDEncoder~SegmentCommandHandler\n     * @param {number} displayNumber - LED position number [0 to numDisplays - 1]\n     * @param {string} segmentCode - segment code, according to standard LED pinout\n     * @param {boolean} on - true, if segment should be lit\n     */\n\n    /**\n     * Encoder options container\n     *\n     * @typedef LEDEncoder~EncoderOptions\n     * @type {object}\n     * @property {boolean} decimalPointSupport - enables decimal point LED segments support,\n     * set to true, if you want to receive `dp` codes to your handlers, set false otherwise\n     */\n}\n","/**\n * Slices a fixed-size moving window through the text string, cycling around it\n *\n * @param {number} start - window's left boundary (inclusive)\n * @param {number} end - window's right boundary (inclusive)\n * @param {string} text - text to window through\n */\nexport function offsetTextWrap(start, end, text) {\n    if (end > text.length - 1) {\n        return text.substr(start, text.length - start) + text.substr(0, end - text.length)\n    } else {\n        return text.substr(start, end)\n    }\n}\n\n/**\n * Convert hexadecimal number to binary representation\n * Each hexadecimal ASCII code should be 15 bits (14 segs plus decimal point)\n *\n * @param {number} hex\n * @param {number} maxLength\n * @returns {string}\n */\nexport function hex2bin(hex, maxLength){\n    return hex.toString(2).padStart(maxLength, \"0\")\n}"],"names":["fourteenSegmentASCII","segments","numDisplays","segmentCommandHandler","options","offset","defaultOptions","decimalPointSupport","dpSupportCheckingHandler","dNum","seg","on","_this","this","sendText","text","chNum","count","binaryString","charCodeAt","toString","padStart","NUM_SEGS","Array","from","forEach","b","_this2","substr","length","sendScrollingText","textString","scrollSpeed","timeout","setTimeout","start","end","_this3"],"mappings":"oNA2BaA,EAAuB,CAChC,EACA,MACA,IACA,KACA,KACA,MACA,KACA,IACA,KACA,KACA,MACA,KACA,KACA,IACA,MACA,KACA,KACA,KACA,IACA,IACA,IACA,KACA,IACA,EACA,IACA,IACA,KACA,KACA,KACA,IACA,KACA,MACA,IACA,IACA,KACA,GACA,KACA,IACA,IACA,IACA,IACA,KACA,GACA,KACA,GACA,KACA,KACA,GACA,IACA,KACA,KACA,IACA,KACA,GACA,KACA,MACA,MACA,IACA,KACA,GACA,KACA,GACA,MACA,EACA,IACA,KACA,KACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,GACA,KACA,KACA,IACA,IACA,KACA,GACA,KACA,IACA,GACA,KACA,MACA,MACA,IACA,KACA,KACA,KACA,KACA,KACA,GAISC,EAAW,CACpB,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA,iDCzGA,WAAYC,EAAaC,EAAuBC,mBAvBhDC,OAAS,OAITC,eAAiB,CACbC,qBAAqB,QAIzBC,yBAA2B,SAACC,EAAMC,EAAKC,IAjB3B,OAkBJD,GAAoBE,EAAKR,QAAQG,sBAGrCK,EAAKT,sBAAsBM,EAAMC,EAAKC,IAWtCE,KAAKX,YAAcA,EACnBW,KAAKV,sBAAwBA,EAC7BU,KAAKT,aACES,KAAKP,eACLF,GAlCf,2BA6CIU,SAAA,SAASC,GACL,0BAASC,GACL,IAAIC,EAAQ,EACRC,EAAuBlB,EAAqBe,EAAKI,WAAWH,GArDvD,ICqBNI,SAAS,GAAGC,SDnBNC,GCmB0B,KDiCnCC,MAAMC,KAAKN,GAAcO,QAAQ,SAAAC,GAC7BC,EAAKnB,yBAAyBQ,EAAOf,EAtDpC,GAsDwDgB,GAAc,MAANS,GACjET,OALCD,EAAQ,EAAGA,EAAQD,EAAKa,OAAO,EAAGf,KAAKX,aAAa2B,OAAQb,MAA5DA,MAgBbc,kBAAA,SAAkBC,EAAYC,cACtBC,EAAUD,GAAe,IAC7BE,WAAW,eCjEYC,EAAOC,EAAKrB,EDkE/BsB,EAAKvB,UClEcqB,EDkEUE,EAAKhC,QClER+B,EDkEgBC,EAAKhC,OAASgC,EAAKnC,cClE9Ba,EDkE2CgB,GCjEnEF,OAAS,EACbd,EAAKa,OAAOO,EAAOpB,EAAKc,OAASM,GAASpB,EAAKa,OAAO,EAAGQ,EAAMrB,EAAKc,QAEpEd,EAAKa,OAAOO,EAAOC,KD+DtBC,EAAKhC,SACDgC,EAAKhC,SAAW0B,EAAWF,SAC3BQ,EAAKhC,OAAS,GAElBgC,EAAKP,kBAAkBC,EAAYE,IACpCA"}